## 对C的兼容

- `__func__` 指示所在函数的名字，通过隐式的在函数开头声明`static const char* __func__`实现

  - ```c++
    __FILE__	//指示文件名
    __LINE__	//指示当前行数
    ```

- `_Pragma`

  - `_Pragma(string)` 等于`#pragma string` 

- `__VA_ARGS__`

  - ```c++
    #define LOG(...) {\
    	std::cout << __FILE__<< std::endl \
    		<< __VA_ARGS__ << std::endl; \
    }
    
    LOG(format string);
    ```

- `__cplusplus`

  - ```c++
    #if __cplusplus < 201103L
    	#error ""
    #endif
    ```

- `static_assert(bool expr, string);`

- `noexcept`

  - ```c++
    void func1() noexcept{}
    void func2() noexcept(expression){}
    ```

- `friend`

  - 声明类作为友元时，可以省略class，方便定义模板

  - ```c++
    template<typename T> class A{
        friend T;
    }
    ```

- `final/override`

  - `final`修饰的函数派生类不能重载，`override`修饰的函数必须是派生类中的虚函数，派生类虚函数的`virtual`可以省略

- 默认模板参数

  - 注意：函数默认模板参数位置任意，类默认模板参数必须在最后

- 外部模板`extern`

  - 编译器针对不同文件中的同一模板会先实例化后去重，使用`extern`声明外部模板可以使得只实例化一次

- 局部和匿名类型作模板实参



## 普适

- `using Base::Base`

  - 构造时使用基类构造函数（优先配对派生类的构造函数）
  - 可以用调用基类构造函数+派生类使用默认初始化的防止避免冗余代码

- 委派构造函数

  - 构造函数的参数列表可以选择改成使用另一个构造函数（不能同时使用)，减少冗余代码

- **右值引用**

  - 移动语义（move）：延长右值的声明周期，减少构造/析构次数（移为己用）	`std::move`

    - 特殊的优化，下面代码在开启RVO(Return Value Optimization)时会优化为b直接占用a的内存，不存在任何拷贝/移动

      ```c++
      A getA() { A a(); return a;}
      A b = getA();
      ```

  - 完美转发（forward）

    - 引用折叠：引用第一，定义第二

- 显示转换操作符`explicit`

  - `explicit`关键字可作用于操作符

- 列表初始化

  - 允许使用{}进行初始化
  - 防止类型收窄，如`char a{100};`会无法通过编译

- POD(Plain Old Data)

  - > 平凡的(trivial)：使用默认构造函数，析构函数，赋值运算符（不能有任何自定义），不能有虚函数/虚基类
    >
    > 标准布局(standard layout)：非静态成员访问权限一致，继承时非静态成员不能同时出现在多个基类和派生类，类中第一个非静态成员类型与基类不同*
    >
    > *这是因为c++要求相同的对象必须地址不同，故会为基类分配1字节空间（但是在我的vs2017中，类中第一个非静态成员类型与基类地址是一样的的(-std=c++17)，不过`is_standard_layout<>::value`仍然为0

  - 用处：字节赋值，与C布局兼容，保证静态初始化安全有效

- 非受限联合体`union`

  - c++98不允许联合体拥有POD、静态成员，c++11取消了这些限制
  - 为了避免初始化出现问题，当联合体中有POD成员时，会删除默认构造函数，推荐使用placement new
  - 类中可以使用匿名的联合体

- 自定义字面量`operator "" tag`

  - ```c++
    int operator "" _a(unsigned long long a){ return (int)a; }
    int operator "" _b(const char* s, size_t n) { return n; }
    
    cout << 1234_a << endl;	//1234
    cout << "1234"_b << endl; //1234
    ```

  - 优先调用`unsigned long long`/`long double`版本，过长或字符串调用`const char*, size_t`版本，单字符可调用`char`版本

  - 后缀（如本例中`_a`）建议以下划线开始，不然容易有歧义（会被编译器警告）

- 内联命名空间`inline`

  - 在子命名空间中加上`inline`修饰符，此时子命名空间的内容在父命名空间全局可见

- 别名`using`

  - 基本同`typedef`，但适用面更广，比如可以用于模板

  - ```c++
    template<typename T> using mapString = std::map<T, char*>;
    ```

- **SFINEA**    (Substitution failure is no an error)



## 简化

- 右尖括号`>`

  - C++98会将`>>`优先解释为右移，C++11中则会正确识别，但同时也会误判一堆尖括号中真正的右移符号

  - ```c++
    template<int> class A{};
    template<class T> class B{};
    A<1 >> 5> a;	//c++11会编译失败
    B<A<1>> b;		//c++98会编译失败
    A<(1 >> 5)> c;
    ```

- `auto`类型推导（c++11中失去了c++98中声明为自动变量的特性）

  - 必须是静态的（编译期可推导），有多个声明时按第一个推导

  - 除引用外，`auto`不会考虑变量的`const/volatile`和`&`（需要时需自己添加）

  - > 不能推导的情况（即使有默认值）：
    >
    > 1.函数形参 2.结构体非静态成员变量 3.数组 4.模板参数

- `typeid`

  - `typeid(para)`返回一个`type_info`类型数据，有`name`和`hash_code`两个成员函数

- `decltype`

  - `decltype(expr)`推导表达式的类型，用于声明变量类型

  - > 没带括号时，decltype(e)对应e实体类型，对于重载函数会编译失败
    >
    > 否则，如果e是一个将亡值，decltype(e)为T &&
    >
    > 否则，如果e是一个左值，decltype(e)为T &
    >
    > 否则，decltype(e)为T

  - 继承cv，但对成员的类型推导不会继承cv，*&等不会被忽略（与auto不一样）

- 追踪返回类型

  - `int fun()`等价于`auto fun()->int`
  - 方便返回值复杂的情况`auto fun()-> auto fun1()->int `
  - 这种情况下返回值可以不带作用域

- `for` 

  - ```c++
    for(auto num : nums) {}
    ```



## 类型安全

- 强枚举类型

  - ```c++
    enum class TYPE1 {};
    enum class TYPE2 : char {};
    ```

  - > 强作用域：成员名称对父空间不可见
    >
    > 转换限制：不会隐式转换为整型
    >
    > 可以指定底层类型：`: type`（普通的枚举类型也可以）

- 堆内存管理：智能指针

  - `unique_ptr`,`shared_ptr`,`weak_ptr`

  - `weak_ptr`调用`lock()`函数返回一个对应的`shared_ptr`指针

  - 垃圾回收的方式：

    > 1.基于引用计数
    >
    > 优点：实现简单，不会造成暂停，副作用小
    >
    > 缺点：环形引用，额外空间开销
    >
    > 2.基于跟踪处理
    >
    > 标记-清除，额外的有标记-整理，标记-拷贝（防止内存碎片）

  - 垃圾回收机制与指针灵活使用是冲突的



## 性能

- `constexpr`常量表达式

  - 常量表达式函数：

    > 只有单一return语句（可以有不产生实际代码的语句，如静态断言、using）
    >
    > 必须返回值，返回常量表达式，使用前有定义
    >
    > 不能有赋值操作

  - 不用于修饰自定义类型，但可以用于修饰构造函数、成员函数

    > 构造函数：函数体必须为空，初始化列表必须由常量表达式赋值

  - 用于模板时：当不满足常量要求时，会忽略`constexpr`

  - 编译器对常量表达式支持至少512层的递归（`constexpr`元编程）

- 变长模板

  - 